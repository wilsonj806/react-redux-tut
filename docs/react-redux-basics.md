# React Redux basics

## General Description

We have our `store` for storing state, and we have reducers for handling state changes, but we'll need to integrate this all with our React components/ app. React-Redux introduces a new design pattern to handle all of this, presentational/ container components, which will be elaborated on here.

Before we begin, make sure you have the official React-Redux bindings!
  ```
  npm i react-redux
  ```

## Presentational and Container Components

The React-Redux bindings make a distinction between presentational and container components. In short, it distinguishes between components that renders as a UI element, and components that handle and pass around data.

See the below table for a quick summary or this [Medium article](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0) for more.

|  | **Presentational** | **Container** |
|--------------------|--------------------------------|----------------------------------------------|
| **Purpose** | How things look(markup, style) | How things work(data fetching, state update) |
| **Aware of Redux** | No | Yes |
| **To read data** | Read data from props | Subscribe to Redux state |
| **To change data** | Invoke callbacks from props | Dispatch Redux actions |
| **Are written** | By hand | Generated by React Redux |

Most of the components we write will be presentational, but we'll need to have container components to handle state.

Technically you could write the container components by hand using `store.subscribe()`. The Redux docs don't recommend doing this as React Redux makes performance optimizations that you probably shouldn't try. We'll be using React Redux's `connect()` function to write them instaed.

## React Component Hierarchy

> Our design brief is simple. We want to show a list of todo items. On click, a todo item is crossed out as completed. We want to show a field where the user may add a new todo. In the footer, we want to show a toggle to show all, only completed, or only active todos.

### Designing Presentational Components

We have the following presentational components:
- `<TodoList/>`
  - its a list that renders a bunch of `<Todo/>` elements
  - has the following props:
    - todos as an array of todos
    - onTodoClick handler as a callback to invoke if a todo is clicked
- `<Todo/>`
  - it renders a todo item which has the following props:
    - the todo as a string
    - if the todo is completed as a checkbox
    - an onclick handler
- `<Link/>`
  - it's a link with an onclick handler
- `<Footer/>`
  - lets the user change currently visible todos

These components know what to do when it gets the data, but it won't actually directly access the store in order to change or update itself. There's just enough scripting required to render information in and it does not need Redux to render information.
  - i.e you can render them even without Redux or state

### Designing Container Components

Container components on the other hand, actually access the `store` and uses that data to help render presentational components.

We'll need the following:
- `<VisibileFilterList/>`
  - displays todos depending on which visibility filter option is enabled
- `<FilterLink/>`
  - gets the current visibility filter and renders a `<Link/>`
    - `filter: string` is the visibility it represents

### Designing Other Components

Course not everything falls into the above two categories. For example, given the below component:
- `<AddTodo/>` is an input field with an "Add" button
It could be split into two different components, but it'd be too early to do so. If the component is small enough in function, then it's fine to mix the two. As the app grows in size and functionality, it'll be more obvious how to split it, but it's fine for now.

## Implementing Container Components

Implementing presentational components is pretty straight-forwards, container components on the other hand are where this gets interesting.

For the purposese of this tutorial project, a container component is just a component that uses `store.subscribe()`. This is generally going to end up with a [higher order component](https://reactjs.org/docs/higher-order-components.html) that we could implement by ourselves, but the official React Redux bindings provides us with `connect()` to use (which has optimizations built in already).

To use `connect()` to generate our HOC, we need to define a `mapStateToProps` function that will transform the current Redux store state into React props that we'll be passing into the presentational components that is being wrapped by the HOC.

In the case of a `<VisibilTodoList/>` component, we need to determine which `todos` to pass into `<TodoList/>`, so we'll also need a function that filters `state.todos` based on the current Visibility Filter value.
  - and if we need more data from the Redux store, we'll need to make more functions to handle that

The two functions would look like the below:

  ```js
  const getVisibleTodos = (todos, filter) => {
    switch (filter) {
      case 'SHOW_COMPLETED':
        return todos.filter(t => t.completed)
      case 'SHOW_ACTIVE':
        return todos.filter(t => !t.completed)
      case 'SHOW_ALL':
      default:
        return todos
    }
  }

  const mapStateToProps = state => {
    return {
      todos: getVisibleTodos(state.todos, state.visibilityFilter)
    }
  }
  ```
Also since we click on our `<Todo/>` elements to update state, we'll need a function to handle dispatching an action to the Redux store. This function will be called `mapDispatchToProps` and will use `toggleTodo` as the injected `onTodoClick` handler.

  ```js
  const mapDispatchToProps = dispatch => {
    return {
      onTodoClick: id => {
        dispatch(toggleTodo(id))
      }
    }
  }
  ```
The final component ends up looking like [this file](../src/containers/VisibleTodoList.js)